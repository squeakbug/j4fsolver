{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE StandaloneDeriving  #-}

module LibSolver.Search.Problem
    ( 
    ) where

-- |Тип, используемый для представления стоимости, связанной с определенным путем.
type Cost = Double

-- |Проблема (пространство состояний):
--  s - тип состояния
--  a - тип действия агента
-- 
--  Минимально требуется реализовать метод 'initial' и 'successor', и одну из функций:
--  'goal' - если возможно сравнить состояние с конечным состоянием 
--  'goalTest' - если цель конечное состояние определяется по предикату
class Eq s => Problem p s a where
    -- | Начальное состояние
    initial :: p s a -> s

    -- | Given a state, return a sequence of (action, state) pairs reachable
    --   from this state. Because of lazy evaluation we only ever compute as
    --   many elements of the list as the program needs.
    successor :: p s a -> s -> [(a, s)]
    
    -- | Если у задачи есть только одно конечное состояние, этот метод должен вернуть его
    goal :: p s a -> s
    goal = undefined

    -- | Возвращает true, если состояние является целью. 
    --   Метод по умолчанию сравнивает состояние с состоянием, указанным в реализации 'goal'. 
    --   Вы можете переопределить этот метод, если для определения конечной используется определенный предикат
    goalTest :: p s a -> s -> Bool
    goalTest p s = s == goal p

    -- | Возвращает стоимость пути решения, которое исходит из первого состояния и завершается вторым состоянием. 
    --   Если проблема такова, что путь не имеет значения, то функция будет учитывать только второе состояние. 
    --   В реализации по умолчанию стоимость каждого шага на пути равна 1.
    costP :: p s a -> Cost -> s -> a -> s -> Cost
    costP _ c _ _ _ = c + 1

    -- | Возможно, вы захотите указать эвристическую функцию для этой задачи. 
    --   Реализация по-умолчанию всегда возвращает ноль.
    -- 
    --   Это аналог 'h' функции из AIMA. Пример использования можно найти в реализации A* алгоритма
    heuristic :: p s a -> Node s a -> Cost
    heuristic _ = const 0

    -- | В задачах оптимизации каждое состояние имеет свое значение. 
    --   Hill-climbing и связанные с ним алгоритмы пытаются максимизировать это значение. 
    --   Реализация по умолчанию всегда возвращает ноль.
    valueP :: p s a -> s -> Double
    valueP _ = const 0
